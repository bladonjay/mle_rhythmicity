function [thetaindex,p,f,F,theta_index_ci,lowsig,highsig,blow,bhigh] = theta_index(x_,varargin)
%THETA_INDEX Calculates the theta index and confidence intervals
% Calculates the theta-index as in Yartsev et al, 2011, Nature. See also:
% Boccara et al, 2010, Nature Neurosci; Langston et al, 2010 Science; Wills
% et al, 2010, Science; and Deshmukh et al, 2010, J. Neurophysiol.
%
% Using a model of the autocorrelogram at a series of Poisson counts, also
% calculates confidence intervals on the theta index.
%
% INPUT
%   x: Data. Can either be spike timestamps, a cell array of lags, or a
%       histogram of lag counts.
% PARAMETERS
%   calcp (true): Bootstaps the null distribution by shuffling lags by 1/2
%       of a cycle of the peak frequency detected.  If false, does not run
%       and p=NaN, but runs much faster.
%   pmethod (bootstrap): Can also be "urnd", in which case a large
%       shuffle is assumed and N windows of spikes with uniform random
%       distribution are used, where N is the number of spikes. If this is
%       urnd, "rate" must be set
%   rate ([]): The average rate of the neuron
%   t (0:0.01:0.6): The edges of the lag bins.
%   ishist (false): Set to true if input data is a histogram.
%   calcci (true): Calculates the region of confidence (0.95) around the
%       autocorrelogram for the true underlying rates, and finds the least
%       and most theta-rhythmic (by the theta index) rate profiles in this
%       range. If false, does not run and
%       theta_index_ci,lowsig,highsig,blow and bhigh are all NaN, but runs
%       much faster
% RETURNS
%   thetaindex: The theta index - the ratio of the average power within 1
%       Hz of the peak in the theta (5-11 Hz) range and the average power
%       in the whole spectrum of the zero-mean spike time autocorrelation
%   p: The boostrapped significance of the autocorrelation
%   f: The peak theta frequency detected
%   F: The bootstrapped null distribution
%   theta_index_ci: The confidence intervals on the theta index.
%   lowsig: The rate profile found with the lowest theta index.
%   highsig: The rate profile found with the highest theta index.
%   blow: The low side of the 95% confidence range for the rate profile.
%   bhigh: The high side of the 95% confidence range for the rate profile.
%
% This code has been freely distributed by the authors. If used or
% modified, we would appreciate it if you cited our paper, <paper
% information here>.
%
% Copyright (c) 2014, Trustees of Boston University
% All rights reserved.
%
% This file is part of mle_rhythmicity
%
% This version of mle_rhythmicity is solely for the purposes of review and
% demonstration of its functionality by editors and reviewers.
% Redistribution to others and other uses in source and binary forms, with
% or without modification, is prohibited.  Upon acceptance for publication,
% this code and future versions modified by the authors will be made
% permanently available at
% https://mind4.bu.edu/distributed_code/mle_rhythmicity/ under the BSD
% license (Available at http://opensource.org/licenses/bsd-license.php)
% allowing future users to freely distribute and modify the code.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
% IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
% CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
% EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
% PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
% PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
% LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
% NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
% SOFTWARE, EVEN IN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

%% Parse input
p = inputParser;
p.addParamValue('calcp',true);
p.addParamValue('ishist',false);
p.addParamValue('calcci',true);
p.addParamValue('rate',[]);
p.addParamValue('t',0:0.01:0.5);
p.addParamValue('pmethod','bootstrap');
p.addParamValue('shufflet',10);
p.parse(varargin{:});
for j = fields(p.Results)'
    eval([j{1} ' = p.Results.' j{1} ';']);
end

T = max(t);


if ishist
    b = x_(:);
elseif iscell(x_)
    x = x_(:);
    x_ = [];
    try
    b = histc(cat(1,x{:}),t);
    catch err
        b = histc(cat(2,x{:}),t);
    end
    b = b(1:end-1);
else
    spk_ts = x_(:);
    x_ = x_(:)';
    x = arrayfun(@(x)spk_ts(spk_ts>x&spk_ts<=x+T)-x,spk_ts,'UniformOutput',false);
    b = histc(cat(1,x{:}),t);
    b = b(1:end-1);
end

b = b(:);

if numel(b)==numel(t)-1
   b = [flipud(b);max(b(:));b]; 
end


% Calculate theta index
Fs = 0.01^-1;
NFFT = 2^16;
f = Fs/2*linspace(0,1,NFFT/2+1);
Y = fft(b-mean(b),NFFT);
Y = abs(Y(1:NFFT/2+1)).^2;
Y = conv(Y,ones(1,round(2/mode(diff(f)))),'same')';
[~,pk] = nanmax((f(:)>5&f(:)<11).*Y(:));
pk0 = pk;

thetaindex = mean(Y(abs(f-f(pk))<=1))/mean(Y);
p = NaN;
F = NaN;
theta_index_ci = NaN;

%% Calculate confidence intervals on theta index
if calcci
%     keyboard
    if (isempty(x_)||~iscell(x_))&&iscell(x)
        n = numel(x);
    elseif iscell(x_)
        n = numel(x_);
    end
    
    b2 = b(numel(t)+1:end);
    blow = b2*0;
    blow(b2~=0) = arrayfun(@(b2)fzero(@(mu)poisscdf(b2,mu*n)-1+0.05/2,[0 10*b2/n]),b2(b2~=0))*n;
    bhigh = arrayfun(@(b2)fzero(@(mu)poisscdf(b2,n*mu)-0.05,[0 10*max(b2,1)/n]),b2)*n;
    
    theta_index_ci = [0 0];
    
    % Find underlying rate profile with lowest theta index
    [lowsig,theta_index_ci(1)] = fmincon(...
        @(x)confun(x,bhigh,blow)...
        ,b2...
        ,[],[],[],[]...
        ,blow...
        ,bhigh...
        ,[]...
        ,optimset('Algorithm','active-set','TolFun',1e-4,'TolX',1e-4)...
        );
        
    % Find underlying rate profile with highest theta index
    [highsig,theta_index_ci(2)] = fmincon(...
        @(x)-confun(x,bhigh,blow)...
        ,b2...
        ,[],[],[],[]...
        ,blow...
        ,bhigh...
        ,[]...
        ,optimset('Algorithm','active-set','TolFun',1e-3,'TolX',0.01)...
        );
    
    theta_index_ci(2) = -theta_index_ci(2);
end

%% Bootstrap: uniformly jitter lag by 1/2 cycle and recalculate
N = 1000;

if calcp
    switch pmethod
        case 'bootstrap'
            
%             keyboard
            
           if isequal(shufflet,'adapt')
               shufflet = 1/(f(pk0)-1)/2;
            end
            
            F = zeros(N,1);
            
            for j=1:N
%                 % disp(j)
                try
                shuffled_b = abs(unifrnd(cat(1,x{:})-shufflet,cat(1,x{:})+shufflet));
                catch err
                    shuffled_b = abs(unifrnd(cat(2,x{:})-shufflet,cat(2,x{:})+shufflet));
                end
                shuffled_b(shuffled_b>T) = 2*T-shuffled_b(shuffled_b>T);
                shuffled_b(shuffled_b<=0) = -shuffled_b(shuffled_b<=0);
                shuffled_b = histc(shuffled_b,t);
                shuffled_b = shuffled_b(1:end-1);
                shuffled_b = shuffled_b(:);
                shuffled_b = [flipud(shuffled_b);max(shuffled_b);shuffled_b];
                
                Y = fft(shuffled_b-mean(shuffled_b),NFFT);
                Y = abs(Y(1:NFFT/2+1)).^2;
                Y = smooth(Y,2/mode(diff(f)));
                [~,pk] = nanmax((f>5&f<11).*Y');
                F(j) = mean(Y(abs(f-f(pk))<=1))/mean(Y);
                
            end
        case 'shuffle'
            %%
%             keyboard
            if isequal(shufflet,'adapt')
               shufflet = 1/(f(pk0)-1)/2;
            end
            
            F = zeros(N,1);
            t = t;
            for i=1:N
                % disp(i)
                F(i) = theta_index(spk_ts(:)+rand(numel(spk_ts),1)*shufflet*2-shufflet,'calcp',false,'calcci',false,'t',t);
            end
        otherwise
            return
    end
    p = sum(F>thetaindex)/N;     
end

f = f(pk0);

end

function [ c ] = confun( x, high, low )
c = theta_index(x,'calcp',false,'ishist',true,'calcci',false);
end